// <copyright file="LIBP1001.cs" company="JSSoft">
//   Copyright (c) 2025 Jeesu Choi. All Rights Reserved.
//   Licensed under the MIT License. See LICENSE.md in the project root for license information.
// </copyright>

using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace JSSoft.Modelora.Analyzers.Items;

internal sealed class LIBP1001 : ItemBase
{
    public override void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var modelClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is TypeDeclarationSyntax typeDecl && typeDecl.AttributeLists.Count > 0,
                transform: static (ctx, _) => (
                    Declaration: (TypeDeclarationSyntax)ctx.Node,
                    IsPartial: ((TypeDeclarationSyntax)ctx.Node).Modifiers.Any(SyntaxKind.PartialKeyword),
                    ctx.SemanticModel));

        context.RegisterSourceOutput(modelClasses, (spc, classInfo) =>
        {
            var declaration = classInfo.Declaration;
            var semanticModel = classInfo.SemanticModel;
            if (!IsModelObject(declaration, semanticModel))
            {
                return;
            }

            if (!ContainsEnumerableProperty(declaration, semanticModel))
            {
                return;
            }

            var isPartial = declaration.Modifiers.Any(SyntaxKind.PartialKeyword);
            if (isPartial)
            {
                var identifier = declaration.Identifier.ValueText;
                var sourceName = $"{identifier}.g.cs";
                var source = GenerateSource(declaration, semanticModel);
                var sourceText = SourceText.From(source, Encoding.UTF8);
                spc.AddSource(sourceName, sourceText);
            }
            else
            {
                var descriptor = new DiagnosticDescriptor(
                    id: "LIBP1001",
                    title: "Model class must be declared as partial",
                    messageFormat: "The class '{0}' with [JSSoft.Modelora.ModelAttribute] attribute must be declared as partial",
                    category: "JSSoft.Modelora",
                    defaultSeverity: DiagnosticSeverity.Error,
                    isEnabledByDefault: true);

                var diagnostic = Diagnostic.Create(
                    descriptor,
                    declaration.GetLocation(),
                    declaration.Identifier.Text);

                spc.ReportDiagnostic(diagnostic);
            }
        });
    }

    private static string GenerateSource(TypeDeclarationSyntax declaration, SemanticModel semanticModel)
    {
        using var tw = new IndentedTextWriter();
        var ns = declaration.GetNamespace();
        var name = declaration.GetName();

        tw.WriteLine("// <auto-generated/>");
        tw.WriteLine("// This file is auto-generated by JSSoft.Modelora.Analyzers.ModelIncrementalGenerator.");
        tw.WriteLine("// Do not edit this file manually.");
        tw.WriteLine();

        tw.WriteLine("#nullable enable");

        if (ns != string.Empty)
        {
            tw.WriteLine($"namespace {ns}");
            tw.WriteLine("{");
            tw.Indent();
        }

        if (declaration.IsPublic())
        {
            tw.Write("public ");
        }
        else if (declaration.IsInternal())
        {
            tw.Write("internal ");
        }
        else if (declaration.IsProtected())
        {
            tw.Write("protected ");
        }
        else if (declaration.IsPrivate())
        {
            tw.Write("private ");
        }

        tw.Write("partial ");

        if (declaration.IsRecord())
        {
            if (declaration.IsStruct())
            {
                tw.Write("record struct ");
            }
            else if (declaration.IsClass())
            {
                tw.Write("record class ");
            }
            else
            {
                tw.Write("record ");
            }
        }
        else if (declaration.IsClass())
        {
            tw.Write("class ");
        }
        else if (declaration.IsStruct())
        {
            tw.Write("struct ");
        }

        tw.Write(@$"{name}");

        if (!IsEuquatableInterfaceDefined(declaration, semanticModel))
        {
            tw.Write(" : System.IEquatable<" + name + ">");
        }

        tw.WriteLine();
        tw.WriteLine("{");
        tw.Indent();

        if (!IsGetHashCodeMethodDefined(declaration))
        {
            tw.WriteLine("public override int GetHashCode()");
            tw.Indent();
            tw.WriteLine("=> JSSoft.Modelora.ModelResolver.GetHashCode(this);");
            tw.Unindent();
            tw.WriteLine();
        }

        if (!IsEquatableMethodDefined(declaration))
        {
            if (declaration.IsStruct())
            {
                tw.WriteLine($"public bool Equals({name} other)");
                tw.Indent();
                tw.WriteLine("=> JSSoft.Modelora.ModelResolver.Equals(this, other);");
                tw.Unindent();
            }
            else
            {
                tw.WriteLine($"public bool Equals({name}? other)");
                tw.Indent();
                tw.WriteLine("=> JSSoft.Modelora.ModelResolver.Equals(this, other);");
                tw.Unindent();
            }

            tw.WriteLine();
        }

        tw.Unindent();
        tw.WriteLine("}");

        if (ns != string.Empty)
        {
            tw.Unindent();
            tw.WriteLine("}");
        }

        tw.WriteLine();

        return tw.ToString();
    }

    private static bool IsModelObject(TypeDeclarationSyntax typeDeclaration, SemanticModel semanticModel)
    {
        var query = from attributeList in typeDeclaration.AttributeLists
                    from attribute in attributeList.Attributes
                    let symbol = semanticModel.GetSymbolInfo(attribute).Symbol as IMethodSymbol
                    where symbol != null
                    let attributeType = symbol.ContainingType
                    where attributeType.ToDisplayString() == "JSSoft.Modelora.ModelAttribute"
                    select attributeType;

        return query.Any();
    }

    private static bool IsEuquatableInterfaceDefined(TypeDeclarationSyntax declaration, SemanticModel semanticModel)
    {
        var symbol = semanticModel.GetDeclaredSymbol(declaration);
        if (symbol is null)
        {
            return false;
        }

        return symbol.Interfaces.Any(i => i.ToDisplayString() == "System.IEquatable<" + declaration.GetName() + ">");
    }

    private static bool IsGetHashCodeMethodDefined(TypeDeclarationSyntax declaration)
    {
        var methodSyntax = declaration.Members
            .OfType<MethodDeclarationSyntax>()
            .FirstOrDefault(m =>
                m.Identifier.ValueText == "GetHashCode" &&
                m.ParameterList.Parameters.Count == 0 &&
                m.Modifiers.Any(SyntaxKind.OverrideKeyword));

        if (methodSyntax != null)
        {
            return true;
        }

        return false;
    }

    private static bool IsEquatableMethodDefined(TypeDeclarationSyntax declaration)
    {
        var methodSyntax = declaration.Members
            .OfType<MethodDeclarationSyntax>()
            .FirstOrDefault(m =>
                m.Identifier.ValueText == "Equals" &&
                m.ParameterList.Parameters.Count == 1);

        if (methodSyntax != null)
        {
            var parameterType = methodSyntax.ParameterList.Parameters[0].Type;
            if (parameterType != null)
            {
                var typeName = declaration.GetName();
                var paramTypeName = parameterType.ToString();

                if (declaration.IsClass())
                {
                    return paramTypeName == typeName || paramTypeName == typeName + "?" || paramTypeName.Contains(typeName);
                }
                else
                {
                    return paramTypeName == typeName || paramTypeName.Contains(typeName);
                }
            }

            return true;
        }

        return false;
    }

    private static bool IsSerializableProperty(PropertyDeclarationSyntax propertyDeclaration, SemanticModel semanticModel)
    {
        if (propertyDeclaration.AttributeLists.Count == 0)
        {
            return false;
        }

        var query = from attributeList in propertyDeclaration.AttributeLists
                    from attribute in attributeList.Attributes
                    let symbol = semanticModel.GetSymbolInfo(attribute).Symbol as IMethodSymbol
                    where symbol != null
                    let attributeType = symbol.ContainingType
                    where attributeType.ToDisplayString() == "JSSoft.Modelora.PropertyAttribute"
                    select attributeType;

        return query.Any();
    }

    private static bool IsEnumerableProperty(PropertyDeclarationSyntax propertyDeclaration, SemanticModel semanticModel)
    {
        var typeInfo = semanticModel.GetTypeInfo(propertyDeclaration.Type);
        if (typeInfo.Type == null)
        {
            return false;
        }

        if (typeInfo.Type.ToDisplayString() == "string" ||
            typeInfo.Type.ToDisplayString() == "System.String")
        {
            return false;
        }

        if (typeInfo.Type.ToDisplayString() == "System.Collections.IEnumerable")
        {
            return true;
        }

        foreach (var item in typeInfo.Type.AllInterfaces)
        {
            if (item.ToDisplayString() == "System.Collections.IEnumerable")
            {
                return true;
            }
        }

        return false;
    }

    private static bool ContainsEnumerableProperty(TypeDeclarationSyntax declaration, SemanticModel semanticModel)
    {
        var properties = declaration.Members.OfType<PropertyDeclarationSyntax>();

        foreach (var property in properties)
        {
            if (IsSerializableProperty(property, semanticModel) &&
                IsEnumerableProperty(property, semanticModel))
            {
                return true;
            }
        }

        return false;
    }
}
